/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { MezzuriteConstants } from '../utils/performance-constants';
import { MezzuriteUtils } from './performance-utils.service';
import { MezzuriteMeasure } from '../utils/performance-measure';
/**
 * Class containing core timing functions
 */
export class PerformanceTimingService {
    /**
     * Creates measure object from given set of performance marks
     * @param {?} name full semicolon delimited name
     * @param {?=} slowestResource Slowest resource inside component
     * @param {?=} maxComponentEndTime Max component end time (if VLT)
     * @return {?}
     */
    static measure(name, slowestResource = null, maxComponentEndTime = null) {
        /** @type {?} */
        let startEntry;
        /** @type {?} */
        let endEntry;
        /** @type {?} */
        const componentTitle = MezzuriteUtils.getFullNamePart(name, MezzuriteConstants.fullNamePartTitle);
        /** @type {?} */
        const key = MezzuriteUtils.getFullNamePart(name, MezzuriteConstants.fullNamePartKey);
        if (name === undefined) {
            return;
        }
        if (componentTitle === MezzuriteConstants.altName) {
            // ALT
            endEntry = performance.getEntriesByName(MezzuriteConstants.altMarkEnd)[0];
        }
        else if (componentTitle === MezzuriteConstants.vltName) {
            // VLT
            startEntry = performance.getEntriesByName(MezzuriteConstants.vltMarkStart)[0];
            endEntry = {
                startTime: maxComponentEndTime
            };
        }
        else {
            // Component
            startEntry = performance.getEntriesByName(key + MezzuriteConstants.componentMarkStart)[0];
            endEntry = performance.getEntriesByName(key + MezzuriteConstants.componentMarkEnd)[0];
        }
        /** @type {?} */
        const renderStartEntry = performance.getEntriesByName(key + MezzuriteConstants.componentMarkRenderStart)[0];
        /** @type {?} */
        const startTime = startEntry !== undefined ? startEntry.startTime : 0;
        /** @type {?} */
        let endTime = endEntry.startTime;
        // reset end time to end of slowest resource if
        if (slowestResource !== null && slowestResource.responseEnd > endTime) {
            endTime = slowestResource.responseEnd;
        }
        /** @type {?} */
        const mountDuration = endEntry.startTime - startTime;
        /** @type {?} */
        const totalDuration = endTime - startTime;
        /** @type {?} */
        const nameArr = name.split(';');
        /** @type {?} */
        const obj = new MezzuriteMeasure();
        obj.name = nameArr[1];
        obj.id = nameArr[2];
        obj.startTime = startTime % 1 !== 0 ? parseFloat(startTime.toFixed(1)) : startTime;
        obj.endTime = parseFloat(endTime.toFixed(1));
        obj.untilMount = parseFloat(mountDuration.toFixed(1));
        obj.clt = parseFloat(totalDuration.toFixed(1));
        obj.slowResource = {};
        if (slowestResource && slowestResource.responseEnd >= startTime) {
            (/** @type {?} */ (obj)).slowResource['endTime'] = parseFloat(slowestResource.responseEnd.toFixed(1));
            (/** @type {?} */ (obj)).slowResource['name'] = slowestResource.name;
        }
        else if (slowestResource !== null) {
            (/** @type {?} */ (obj)).slowResource['endTime'] = -1;
            (/** @type {?} */ (obj)).slowResource['name'] = slowestResource.name;
        }
        if (componentTitle !== MezzuriteConstants.altName && componentTitle !== MezzuriteConstants.vltName && renderStartEntry) {
            (/** @type {?} */ (obj))['renderStartTime'] = renderStartEntry.startTime;
        }
        (/** @type {?} */ (window)).mezzurite.measures.push(obj);
    }
    /**
     * Gets measures by name
     * @param {?} name name
     * @return {?}
     */
    static getMeasuresByName(name) {
        /** @type {?} */
        const result = [];
        if (name === undefined || name === null) {
            return null;
        }
        /** @type {?} */
        const measures = (/** @type {?} */ (window)).mezzurite.measures;
        for (let i = 0; i < measures.length; i++) {
            if (name === measures[i].name) {
                result.push(measures[i]);
            }
        }
        return result;
    }
    /**
     * Gets a specific measure by id
     * @param {?} id id
     * @return {?}
     */
    static getMeasureById(id) {
        if (id === undefined || id === null) {
            return null;
        }
        /** @type {?} */
        const measures = (/** @type {?} */ (window)).mezzurite.measures;
        for (let i = 0; i < measures.length; i++) {
            if (id === measures[i].id) {
                return measures[i];
            }
        }
        return null;
    }
    /**
     * Gets a specific measure by name and id
     * @param {?} name name
     * @param {?} id id
     * @return {?}
     */
    static getMeasureByNameAndId(name, id) {
        if (name === undefined || name === null || id === undefined || id === null) {
            return null;
        }
        /** @type {?} */
        const measures = (/** @type {?} */ (window)).mezzurite.measures;
        for (let i = 0; i < measures.length; i++) {
            if (name === measures[i].name && id === measures[i].id) {
                return measures[i];
            }
        }
        return null;
    }
    /**
     * Gets current components from a given capture cycle
     * @return {?}
     */
    static getCurrentComponents() {
        /** @type {?} */
        const components = (/** @type {?} */ (window)).mezzurite.measures.filter((m) => m.name.indexOf(MezzuriteConstants.measureNamePrefix + ';' + MezzuriteConstants.altName) === -1 &&
            m.name.indexOf(MezzuriteConstants.measureNamePrefix + ';' + MezzuriteConstants.vltName) === -1 &&
            m.startTime >= (/** @type {?} */ (window)).mezzurite.startTime &&
            m.startTime <= (/** @type {?} */ (window)).mezzurite.endTime);
        return components;
    }
    /**
     * Gets lookup object of current components
     * @return {?}
     */
    static getCurrentComponentsLookup() {
        /** @type {?} */
        const components = (/** @type {?} */ (window)).mezzurite.measures.filter((m) => m.name.indexOf(MezzuriteConstants.measureNamePrefix + ';' + MezzuriteConstants.altName) === -1 &&
            m.name.indexOf(MezzuriteConstants.measureNamePrefix + ';' + MezzuriteConstants.vltName) === -1 &&
            m.startTime >= (/** @type {?} */ (window)).mezzurite.startTime &&
            m.startTime <= (/** @type {?} */ (window)).mezzurite.endTime);
        /** @type {?} */
        const obj = {};
        for (let i = 0; i < components.length; i++) {
            obj[MezzuriteConstants.measureNamePrefix + ';' + components[i].name + ';' + components[i].id] = components[i];
        }
        return obj;
    }
    /**
     * Calculates viewport load time
     * @return {?}
     */
    static calculateVlt() {
        /** @type {?} */
        let maxComponent = null;
        /** @type {?} */
        let maxEndTime = 0;
        /** @type {?} */
        const vltComponents = [];
        /** @type {?} */
        const components = this.getCurrentComponentsLookup();
        /** @type {?} */
        const vltLookup = (/** @type {?} */ (window)).mezzurite.vltComponentLookup;
        /** @type {?} */
        let measure;
        for (const key in vltLookup) {
            if (components[key] && vltLookup[key] === true) {
                vltComponents.push(components[key]);
                if (maxComponent !== null) {
                    /** @type {?} */
                    let slowestResourceEnd = 0;
                    /** @type {?} */
                    const slowestResource = (/** @type {?} */ (window)).mezzurite.slowestResource[key];
                    if (slowestResource !== undefined && slowestResource !== null) {
                        slowestResourceEnd = slowestResource.responseEnd;
                    }
                    /** @type {?} */
                    const maxLast = maxComponent.clt + maxComponent.startTime;
                    /** @type {?} */
                    const currLast = components[key].clt + components[key].startTime;
                    if (currLast > maxLast) {
                        maxComponent = components[key];
                        maxEndTime = currLast;
                    }
                }
                else {
                    maxComponent = components[key];
                }
            }
        }
        if (maxComponent !== null) {
            /** @type {?} */
            const fullName = MezzuriteConstants.measureNamePrefix + ';' + MezzuriteConstants.vltName + ';' + maxComponent.id;
            this.measure(fullName, null, maxComponent.endTime);
            measure = this.getMeasureByNameAndId(MezzuriteConstants.vltName, maxComponent.id);
            performance.clearMarks(MezzuriteConstants.vltMarkStart);
        }
        else {
            return null;
            // no components in view
        }
        return {
            vlt: measure.clt,
            components: vltComponents
        };
    }
    /**
     * Creates sub-element lookup object on global mezzurite object
     * @param {?} el
     * @param {?} key
     * @return {?}
     */
    static getElNames(el, key) {
        if ((/** @type {?} */ (window)).mezzurite.childElementNames[key] === undefined) {
            (/** @type {?} */ (window)).mezzurite.childElementNames[key] = [];
        }
        if (el.tagName === 'IMG') {
            (/** @type {?} */ (window)).mezzurite.childElementNames[key].push(el.src);
        }
    }
    /**
     * Calculates slowest resource within a given component element
     * @param {?} el parent element
     * @param {?} fullName component fullname
     * @return {?}
     */
    static calculateSlowestResource(el, fullName) {
        /** @type {?} */
        const key = MezzuriteUtils.getFullNamePart(fullName, MezzuriteConstants.fullNamePartKey);
        /** @type {?} */
        let slowestResource = null;
        MezzuriteUtils.walkDOM(el, key, this.getElNames);
        /** @type {?} */
        const resources = performance.getEntriesByType('resource').filter((r) => (/** @type {?} */ (r)).initiatorType === 'img');
        /** @type {?} */
        const currentResources = (/** @type {?} */ (window)).mezzurite.childElementNames[key];
        if (resources.length === 0) {
            return;
        }
        for (let i = 0; i < currentResources.length; i++) {
            for (let j = 0; j < resources.length; j++) {
                if (currentResources[i] === resources[j].name &&
                    (slowestResource === null || resources[j].responseEnd > slowestResource.responseEnd)) {
                    slowestResource = resources[j];
                }
            }
        }
        (/** @type {?} */ (window)).mezzurite.slowestResource[fullName] = slowestResource;
        return slowestResource;
    }
    /**
     * @return {?}
     */
    static calculateSlowestResourceBatch() {
        /** @type {?} */
        let slow;
        /** @type {?} */
        const elementDict = (/** @type {?} */ (window)).mezzurite.elementLookup;
        for (const prop in elementDict) {
            slow = this.calculateSlowestResource(elementDict[prop], prop);
            if (slow === null) {
                PerformanceTimingService.measure(prop);
            }
            else {
                PerformanceTimingService.measure(prop, slow);
            }
        }
    }
}
//# sourceMappingURL=performance-timing.service.js.map